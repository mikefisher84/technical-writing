# Migrate off of Shopify GraphQL from Mobile App in favor of vanilla Apollo and graphql-codegen

Date: 2021-06-23

## Author

Mike Fisher (@mikefisher84)

## Status

Approved

## Context and Background

(Note for Splice, this company's VP of Eng really wanted to have most of the architecture docs on Confluence, not in the codebase which is why this one is a bit fragmented),

The thinking behind this change is thoroughly documented in the Confluence version of this ADR document I'm just porting it over to GitHub for consistency. Please [read that document for a detailed explanation of the decision under consideration](https://*redacted*.atlassian.net/l/c/NQUr8ywW) and the background behind it. I will note below where things have diverged from that document.

### Scope of change

The big update here is that I now believe it's possible to gradually migrate from the Shopify GraphQL stack, rather than having to make a massive update all at once. My suggested plan is that we implement all new components and tests following the new patterns, and update older components and tests as we come across them. Components, and more notably tests, that use the old libraries and patterns will continue to function normally, even in cases where the component has been updated and the tests have not, and vice versa.

### React Hooks

This hasn't changed from the Confluence doc, but is worth showing again:
Shopify exposes a useQuery hook that requires a query to be passed to it:

```ts
const { data } = useQuery(myQuery);
```

graphql-codegen can generate named React hooks for each query:

```ts
const { data } = useMyQuery();
```

### Generated TypeScript Types

The reduced verbosity of the TypeScript types generated by graphql-codegen vs. those generated by graphql-typescript-definitions, and the benefits of the use of GraphQL fragments still [exists as described in the Confluence doc](https://*redacted*.atlassian.net/wiki/spaces/CE/pages/493355032/ADR+Remove+Shopify+GraphQL+from+Mobile+App+in+favor+of+vanilla+Apollo+and+graphql-codegen#Generated-type-names-%2F-use-of-GraphQL-Fragments). However, the scope of making this shift is now very small, as we have mostly moved away from using types generated from GraphQL queries/mutations outside of the components that use the query/mutation.

### Testing patterns

After some research, we've come up with some better testing patterns than what was originally described in the Confluence doc.

Using a [mocked `ApolloProvider`](https://github.com/*redacted*/*redacted-app-name*/pull/222/files#diff-48764a970503b3486802f63222ed2195) we're able to get a similar benefit to the existing use of `filler`, where partial mock data can be used for testing, and the mock provider will fill in the rest.

Here is what a test using the Shopify `createGraphQLController` and `filler` looks like in the app today:

```tsx
it("renders a message when all days are unavailable", async (): Promise<void> => {
  const graphQL = createGraphQLController({
    OpenDeliveryDayModalButtonFulfillmentDayAvailabilitySummary: filler(query, {
      fulfillmentDayAvailabilitySummary: {
        nextAvailableDay: null,
        fulfillmentDaySummaries: list([1, 10], {
          status: "soldout",
        }),
      },
    }),
  });

  const { queryByText } = render({ client: graphQL.client });

  await graphQL.resolveAll({ query });

  expect(graphQL).toHavePerformedGraphQLOperation(query);

  await wait(() =>
    expect(queryByText("No available delivery windows")).toBeTruthy()
  );
});
```

And here's what the same test would look like with the new pattern and tools:

```tsx
it("renders a message when all days are unavailable", async (): Promise<void> => {
  const mockResolver = mockQueryResolvers({
    fulfillmentDayAvailabilitySummary: () => ({
      nextAvailableDay: null,
      fulfillmentDaySummaries: () =>
        list([1, 10], () => ({
          status: FulfillmentDayAvailabilityStatus.Soldout,
        })),
    }),
  });

  const { queryByText } = render(
    <ApolloMockProvider customResolvers={mockResolver}>
      <OpenDeliveryDayModalButton />
    </ApolloMockProvider>
  );

  await wait(() =>
    expect(queryByText("No available delivery windows")).toBeTruthy()
  );
});
```

As you can see, the two are very similar in their general structure. A couple of notable differences:

- The mock provider pattern doesn't provide a straightforward way to strongly type mock data as `filler` does. For a detailed explanation of why, see [this PR comment](https://github.com/*redacted*/*redacted-app-name*/pull/222/files#r444467416). It's also worth noting that `filler` can still be used with the new testing pattern if desired, the only difference is that you need to pass the type to `filler`:

before:

```ts
filler(query, {...});
```

after:

```ts
filler<QueryType, Partial<QueryType>>(query, {...});
```

- You don't need to manually resolve queries with the `ApolloMockProvider`. Instead, if you want to test the loading or error states of the component, there are special versions of the mock provider you can use:

```tsx
it("shows an ActivityIndicator while loading", async (): Promise<void> => {
  const { queryByTestId } = render(
    <ApolloLoadingProvider>
      <OpenDeliveryDayModalButton />
    </ApolloLoadingProvider>
  );

  await wait(() => expect(queryByTestId("activityIndicator")).toBeTruthy());
});

it("displays a message when there is an error", () => {
  const { queryByText } = render(
    <ApolloErrorProvider>
      <OpenDeliveryDayModalButton />
    </ApolloErrorProvider>
  );

  await wait(() =>
    expect(queryByText("Sorry, an error occurred")).toBeTruthy()
  );
});
```

I have created a thoroughly-documented PR with the infrastructure to begin migrating [here](https://github.com/*redacted*/*redacted-app-name*/pull/222).

This would mean that we can start using the new patterns and tools with zero disruption, though one notable drawback is that we would not be able to upgrade to Apollo 3 until all components using the Shopify React hooks have been updated (17 components use them by my count). For many components, updating the _source_ code to the new pattern should only require editing a few lines of code. Tests will take more effort to update, but the old tests are compatible with the new pattern.

## Decision

1. Merge [the PR](https://github.com/*redacted*/*redacted-app-name*/pull/222) after review and feedback.
1. Begin using new component and testing patterns for all new components.
1. Update older components when they are updated in course of new feature work.
